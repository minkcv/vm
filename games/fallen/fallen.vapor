// Fallen Colony
// 2018 Will Smith (minkcv)

var previous_GPU_state;
var GPU_state;

// The entire segment 194 is used for 
// storing the dungeon layout
// Dungoen map is 16 rooms x 16 rooms
// The map layout and room layouts are created with map.py
// Lower 4 bits of a byte indicate door configuration
// Upper 4 bits of a byte are an offset into room layout segment
const MAP_SEGMENT 196;

// Map width and height in units of rooms
const MAP_WIDTH 16;
const MAP_HEIGHT 16;
const DOOR_LAYOUT_COUNT 16;

// Door layout types for a room
const DOOR_NO_ROOM 0;
const DOOR_CROSS 1;
const DOOR_HORIZONTAL 2;
const DOOR_VERTICAL 3;
// Tee down indicates that the the open doors are left, down, and right. Up is closed
const DOOR_TEE_DOWN 4;
const DOOR_TEE_UP 5;
const DOOR_TEE_LEFT 6;
const DOOR_TEE_RIGHT 7;
const DOOR_ELBOW_UP_RIGHT 8;
const DOOR_ELBOW_DOWN_RIGHT 9;
const DOOR_ELBOW_DOWN_LEFT 10;
const DOOR_ELBOW_UP_LEFT 11;
const DOOR_DEAD_LEFT 12;
const DOOR_DEAD_RIGHT 13;
const DOOR_DEAD_UP 14;
const DOOR_DEAD_DOWN 15;

// Room layouts are stored starting at this segment in ROM
// Room layouts are 128 bytes each so 2 fit in a segment.
const ROOM_LAYOUT_START_SEGMENT 197; // MAP_SEGMENT + 1
const ROOM_LAYOUT_COUNT 16;
const ROOM_LAYOUT_SIZE 128;
const ROOM_LAYOUT_WALL_COLOR_OFFSET 120;
const ROOM_LAYOUT_TILE_COLOR_OFFSET 124;
var wall_color_0;
var wall_color_1;
var wall_color_2;
var tile_color_0;
var tile_color_1;
var tile_color_2;
// Room layouts omit outer walls
// and are a 12x10 area
// with tile types and tile sprites
// see TILE_T_* and TILE_S_*
const ROOM_LAYOUT_WIDTH 12;
const ROOM_LAYOUT_HEIGHT 10;

// Room layout types
const ROOM_EMPTY 0;
// The room layouts are created in map.py
// Careful not to put too many sprites in a room
// there is a max of 256 on the screen
// and we have used 24 on room bounds already
// We need some left for the player, enemies, and UI

// Lower 4 bits of byte indicate tile type
// Upper 4 bits of byte indicate tile sprite
const TILE_SPRITE_SIZE 64; // Sprite size in bytes
const TILE_WIDTH 16;
const TILE_HEIGHT 16;
const TILE_SPRITE_SEGMENT 131
var tile_sprite_offset;
var tile_sprite_segment_offset;

// Tiles with type greater than 7 will be walls
const TILE_TYPE_WALL 7;

const MAP_START_X 7;
const MAP_START_Y 7;

const MINIMAP_TILE_WIDTH 8;
const MINIMAP_TILE_HEIGHT 8;
const MINIMAP_TILE_MARGIN 2;
const MINIMAP_LEFT_X 226; // 14 tiles * 16 pixels wide + minimap tile margin
const MINIMAP_TOP_Y 162; // Near the bottom, but with enough space for the map
const MINIMAP_SPRITE_SEGMENT 195;
const MINIMAP_TILE_SIZE 16; // Size in bytes of each sprite
var room_layout_minimap; // Local for rendering minimap
var minimap_sprite_offset;

var map_x;
var map_y;
var map_index; // x + (y * MAP_HEIGHT)
var room_layout;
var door_layout;
var has_top_door;
var has_bottom_door;
var has_left_door;
var has_right_door;
var room_index;
var room_layout_segment;

const BUTTON_RIGHT 8;
const BUTTON_LEFT 4;
const BUTTON_DOWN 2;
const BUTTON_UP 1;

const PLAYER_SPRITE_SEGMENT 205;
const PLAYER_SPRITE_OFFSET 0;

// For collision detection
const DOOR_TOP_Y 80;
const DOOR_BOTTOM_Y 112;
const DOOR_LEFT_X 96;
const DOOR_RIGHT_X 128;
const MOVE_SPEED 1;
var player_x;
var player_y;

var wall_left;
var wall_right;
var wall_above;
var wall_below;

// Common locals
var i;
var i2;
var tmp;
var x;
var y;
var x2;
var y2;
var tile_type;
var tile_sprite;
var buttons;
var buttons2;

// Locals for sprite rendering
var sprite_index;
var sprite_segment;

[ 127 , 17 ] = 1; // Enable GPU

map_x = MAP_START_X;
map_y = MAP_START_Y;

// Must be a multiple of MOVE_SPEED
player_x = 112;
player_y = 88;

call loadRoom;
room_layout_segment = ROOM_LAYOUT_START_SEGMENT + 7; // Start screen is the last room layout
room_index = 128;
call renderRoomTiles;

var title_screen;
title_screen = 1;
while title_screen {
    buttons = [ 127 , 0 ];
    buttons2 = [ 127 , 1 ];
    if buttons | buttons2 { // Any button to start
        title_screen = 0;
    }
}

call initPlayer;

call loadRoom;
call renderRoomTiles;
call renderRoomDoors;
call renderRoomBorder;
call renderMiniMap;

var frame;
// Main loop
while 1 {
    if frame << 3 == 0 {
        call playerMovement;
        call renderPlayer;
    }
    frame = frame + 1;
    call waitScreen;
}

func playerMovement {
    buttons = [ 127 , 1 ];
    if buttons & BUTTON_LEFT == BUTTON_LEFT {
        call playerMoveLeft;
    }
    if buttons & BUTTON_RIGHT == BUTTON_RIGHT {
        call playerMoveRight;
    }
    if buttons & BUTTON_UP == BUTTON_UP {
        call playerMoveUp;
    }
    if buttons & BUTTON_DOWN == BUTTON_DOWN {
        call playerMoveDown;
    }

    if player_x == 0 {
        player_x = 200; // 13 tiles, each 16 pixels wide minus half player width
        map_x = map_x - 1;
        call loadRoom;
        call updateRoomBorderColors;
        call renderRoomDoors;
        call renderRoomTiles;
        call renderMiniMap;
    }
    if player_x == 208 { // Right edge
        player_x = 8; // Half player width
        map_x = map_x + 1;
        call loadRoom;
        call updateRoomBorderColors;
        call renderRoomDoors;
        call renderRoomTiles;
        call renderMiniMap;
    }
    if player_y == 0 {
        player_y = 168;
        map_y = map_y - 1;
        call loadRoom;
        call updateRoomBorderColors;
        call renderRoomDoors;
        call renderRoomTiles;
        call renderMiniMap;
    }
    if player_y == 176 { // Screen height minus tile height
        player_y = 8;
        map_y = map_y + 1;
        call loadRoom;
        call updateRoomBorderColors;
        call renderRoomDoors;
        call renderRoomTiles;
        call renderMiniMap;
    }
}

func playerMoveLeft {
    if player_y < TILE_HEIGHT { // In top doorway
        if player_x == DOOR_LEFT_X + MOVE_SPEED {
            return;
        }
    }
    if player_y > 160 { // In bottom doorway
        if player_x == DOOR_LEFT_X + MOVE_SPEED {
            return;
        }
    }
    i = player_x - TILE_WIDTH + MOVE_SPEED;
    i = i >> 4;
    i2 = player_y - TILE_HEIGHT;
    i2 = i2 >> 4;
    wall_left = [ i , i2 ];
    if wall_left {
        return;
    }
    // check with the tile left of the player
    // player_y has an additional tile length because of the room borders
    i2 = player_y - MOVE_SPEED;
    i2 = i2 >> 4;
    wall_left = [ i , i2 ];
    if wall_left {
        return;
    }
    if has_left_door {
        if player_y > DOOR_TOP_Y {
            if player_y < DOOR_BOTTOM_Y - TILE_HEIGHT {
                player_x = player_x - MOVE_SPEED;
                return;
            }
        }
    }
    if player_x > TILE_WIDTH {
        player_x = player_x - MOVE_SPEED;
    }
}

func playerMoveRight {
    if player_y < TILE_HEIGHT { // In top doorway
        if player_x == DOOR_RIGHT_X - TILE_WIDTH + MOVE_SPEED {
            return;
        }
    }
    if player_y > 160 { // In bottom doorway
        if player_x == DOOR_RIGHT_X - TILE_WIDTH + MOVE_SPEED {
            return;
        }
    }
    i = player_x + MOVE_SPEED - 1;
    i = i >> 4;
    i2 = player_y - TILE_HEIGHT;
    i2 = i2 >> 4;
    wall_right = [ i , i2 ];
    if wall_right {
        return;
    }
    
    i2 = player_y - MOVE_SPEED;
    i2 = i2 >> 4;
    wall_right = [ i , i2 ];
    if wall_right {
        return;
    }
    if has_right_door {
        if player_y > DOOR_TOP_Y {
            if player_y < DOOR_BOTTOM_Y - TILE_HEIGHT {
                player_x = player_x + MOVE_SPEED;
                return;
            }
        }
    }
    if player_x < 192 { // 13 tiles, each 16 pixels wide minus player width
        player_x = player_x + MOVE_SPEED;
    }
}

func playerMoveUp {
    if player_x < TILE_WIDTH { // In left doorway
        if player_y == DOOR_TOP_Y + MOVE_SPEED {
            return;
        }
    }
    if player_x > 192 { // In right doorway
        if player_y == DOOR_TOP_Y + MOVE_SPEED {
            return;
        }
    }
    i = player_x - TILE_WIDTH;
    i = i >> 4;
    i2 = player_y - TILE_HEIGHT + MOVE_SPEED;
    i2 = i2 >> 4;
    wall_above = [ i , i2 ];
    if wall_above {
        return;
    }
    
    i = player_x - 1;
    i = i >> 4;
    wall_above = [ i , i2 ];
    if wall_above {
        return;
    }
    if has_top_door {
        if player_x > DOOR_LEFT_X {
            if player_x < DOOR_RIGHT_X - TILE_WIDTH {
                player_y = player_y - MOVE_SPEED;
                return;
            }
        }
    }
    if player_y > TILE_HEIGHT {
        player_y = player_y - MOVE_SPEED;
    }
}

func playerMoveDown {
    if player_x < TILE_WIDTH { // In left doorway
        if player_y == DOOR_BOTTOM_Y - TILE_HEIGHT + MOVE_SPEED {
            return;
        }
    }
    if player_x > 192 { // In right doorway
        if player_y == DOOR_BOTTOM_Y - TILE_HEIGHT + MOVE_SPEED {
            return;
        }
    }
    i = player_x - TILE_WIDTH;
    i = i >> 4;
    i2 = player_y + 1;
    i2 = i2 >> 4;
    wall_below = [ i , i2 ];
    if wall_below {
        return;
    }
    
    i = player_x - 1;
    i = i >> 4;
    wall_below = [ i , i2 ];
    if wall_below {
        return;
    }
    if has_bottom_door {
        if player_x > DOOR_LEFT_X {
            if player_x < DOOR_RIGHT_X - TILE_WIDTH {
                player_y = player_y + MOVE_SPEED;
                return;
            }
        }
    }
    if player_y < 160 { // 11 tiles, each 16 pixels tall minus player width
        player_y = player_y + MOVE_SPEED;
    }
}

// Sets room_layout and door_layout
// Based on map_x and map_y
func loadRoom {
    i = 0;
    map_index = 0;
    while i < map_y {
        map_index = map_index + MAP_HEIGHT;
        i = i + 1;
    }
    map_index = map_index + map_x;
    room_layout = [ MAP_SEGMENT , map_index ];
    door_layout = room_layout & 15; // 0000 1111 mask
    room_layout = room_layout & 240; // 1111 0000 mask
    room_layout = room_layout >> 4;
    room_layout_segment = ROOM_LAYOUT_START_SEGMENT;
    room_index = 0;
    i = 0;
    while i < room_layout {
        if room_index == 128 { // About to overflow room_index, increment the segment
            room_layout_segment = room_layout_segment + 1;
        }
        room_index = room_index + ROOM_LAYOUT_SIZE;
        i = i + 1;
    }
    wall_color_0 = [ room_layout_segment , room_index + ROOM_LAYOUT_WALL_COLOR_OFFSET ];
    wall_color_1 = [ room_layout_segment , room_index + ROOM_LAYOUT_WALL_COLOR_OFFSET + 1 ];
    wall_color_2 = [ room_layout_segment , room_index + ROOM_LAYOUT_WALL_COLOR_OFFSET + 2 ];

    tile_color_0 = [ room_layout_segment , room_index + ROOM_LAYOUT_TILE_COLOR_OFFSET ];
    tile_color_1 = [ room_layout_segment , room_index + ROOM_LAYOUT_TILE_COLOR_OFFSET + 1 ];
    tile_color_2 = [ room_layout_segment , room_index + ROOM_LAYOUT_TILE_COLOR_OFFSET + 2 ];
}

func initPlayer {
    // sprite_segment = 79;
    // sprite_index = 0;
    [ 79 , 0 ] = 144; // Enable and use transparency
    [ 79 , 3 ] = TILE_WIDTH; // Width
    [ 79 , 4 ] = TILE_HEIGHT; // Height
    [ 79 , 5 ] = PLAYER_SPRITE_SEGMENT; // Sprite segment
    [ 79 , 6 ] = PLAYER_SPRITE_OFFSET; // Sprite offset
    [ 79 , 7 ] = 11; // Color from output of `convertsprite`
    [ 79 , 8 ] = 244; // Color from output of `convertsprite`
    [ 79 , 9 ] = 255; // Color from output of `convertsprite`
}

func renderPlayer {
    
    [ 79 , 1 ] = player_x;
    [ 79 , 2 ] = player_y;
}

func renderMiniMap {
    sprite_segment = 79;
    sprite_index = 16;
    if map_x > 0 {
        // Draw layout of room to left
        room_layout_minimap = 15 & [ MAP_SEGMENT , map_index - 1 ];
        i = 0;
        minimap_sprite_offset = 0;
        while i < room_layout_minimap {
            minimap_sprite_offset = minimap_sprite_offset + MINIMAP_TILE_SIZE;
            i = i + 1;
        }
        [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
        [ sprite_segment , sprite_index + 1] = MINIMAP_LEFT_X; // X
        [ sprite_segment , sprite_index + 2] = MINIMAP_TOP_Y + MINIMAP_TILE_HEIGHT + MINIMAP_TILE_MARGIN; // Y
        [ sprite_segment , sprite_index + 3] = MINIMAP_TILE_WIDTH; // Width
        [ sprite_segment , sprite_index + 4] = MINIMAP_TILE_HEIGHT; // Height
        [ sprite_segment , sprite_index + 5] = MINIMAP_SPRITE_SEGMENT; // Sprite segment
        [ sprite_segment , sprite_index + 6] = minimap_sprite_offset; // Sprite offset
        [ sprite_segment , sprite_index + 7] = 255; // Color from output of `convertsprite`
        [ sprite_segment , sprite_index + 8] = 0; // Color from output of `convertsprite`
        [ sprite_segment , sprite_index + 9] = 0; // Color from output of `convertsprite`
    }
    if map_x == 0 {
        [ sprite_segment , sprite_index ] = 0; // Disable
    }
    sprite_index = sprite_index + 16;
    if map_x < MAP_WIDTH {
        // Draw layout of room to right
        room_layout_minimap = 15 & [ MAP_SEGMENT , map_index + 1 ];
        i = 0;
        minimap_sprite_offset = 0;
        while i < room_layout_minimap {
            minimap_sprite_offset = minimap_sprite_offset + MINIMAP_TILE_SIZE;
            i = i + 1;
        }
        [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
        [ sprite_segment , sprite_index + 1] = MINIMAP_LEFT_X + MINIMAP_TILE_WIDTH + MINIMAP_TILE_WIDTH + MINIMAP_TILE_MARGIN + MINIMAP_TILE_MARGIN; // X
        [ sprite_segment , sprite_index + 2] = MINIMAP_TOP_Y + MINIMAP_TILE_HEIGHT + MINIMAP_TILE_MARGIN; // Y
        [ sprite_segment , sprite_index + 3] = MINIMAP_TILE_WIDTH; // Width
        [ sprite_segment , sprite_index + 4] = MINIMAP_TILE_HEIGHT; // Height
        [ sprite_segment , sprite_index + 5] = MINIMAP_SPRITE_SEGMENT; // Sprite segment
        [ sprite_segment , sprite_index + 6] = minimap_sprite_offset; // Sprite offset
        [ sprite_segment , sprite_index + 7] = 255; // Color from output of `convertsprite`
        [ sprite_segment , sprite_index + 8] = 0; // Color from output of `convertsprite`
        [ sprite_segment , sprite_index + 9] = 0; // Color from output of `convertsprite`
    }
    if map_x == MAP_WIDTH - 1 {
        [ sprite_segment , sprite_index ] = 0; // Disable
    }
    sprite_index = sprite_index + 16;
    if map_y > 0 {
        // Draw layout of room above
        room_layout_minimap = 15 & [ MAP_SEGMENT , map_index - MAP_WIDTH ];
        i = 0;
        minimap_sprite_offset = 0;
        while i < room_layout_minimap {
            minimap_sprite_offset = minimap_sprite_offset + MINIMAP_TILE_SIZE;
            i = i + 1;
        }
        [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
        [ sprite_segment , sprite_index + 1] = MINIMAP_LEFT_X + MINIMAP_TILE_WIDTH + MINIMAP_TILE_MARGIN; // X
        [ sprite_segment , sprite_index + 2] = MINIMAP_TOP_Y; // Y
        [ sprite_segment , sprite_index + 3] = MINIMAP_TILE_WIDTH; // Width
        [ sprite_segment , sprite_index + 4] = MINIMAP_TILE_HEIGHT; // Height
        [ sprite_segment , sprite_index + 5] = MINIMAP_SPRITE_SEGMENT; // Sprite segment
        [ sprite_segment , sprite_index + 6] = minimap_sprite_offset; // Sprite offset
        [ sprite_segment , sprite_index + 7] = 255; // Color from output of `convertsprite`
        [ sprite_segment , sprite_index + 8] = 0; // Color from output of `convertsprite`
        [ sprite_segment , sprite_index + 9] = 0; // Color from output of `convertsprite`
    }
    if map_y == 0 {
        [ sprite_segment , sprite_index ] = 0; // Disable
    }
    sprite_index = sprite_index + 16;
    if map_y < MAP_HEIGHT {
        // Draw layout of room below
        room_layout_minimap = 15 & [ MAP_SEGMENT , map_index + MAP_WIDTH ];
        i = 0;
        minimap_sprite_offset = 0;
        while i < room_layout_minimap {
            minimap_sprite_offset = minimap_sprite_offset + MINIMAP_TILE_SIZE;
            i = i + 1;
        }
        [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
        [ sprite_segment , sprite_index + 1] = MINIMAP_LEFT_X + MINIMAP_TILE_WIDTH + MINIMAP_TILE_MARGIN; // X
        [ sprite_segment , sprite_index + 2] = MINIMAP_TOP_Y + MINIMAP_TILE_HEIGHT + MINIMAP_TILE_HEIGHT + MINIMAP_TILE_MARGIN + MINIMAP_TILE_MARGIN; // Y
        [ sprite_segment , sprite_index + 3] = MINIMAP_TILE_WIDTH; // Width
        [ sprite_segment , sprite_index + 4] = MINIMAP_TILE_HEIGHT; // Height
        [ sprite_segment , sprite_index + 5] = MINIMAP_SPRITE_SEGMENT; // Sprite segment
        [ sprite_segment , sprite_index + 6] = minimap_sprite_offset; // Sprite offset
        [ sprite_segment , sprite_index + 7] = 255; // Color from output of `convertsprite`
        [ sprite_segment , sprite_index + 8] = 0; // Color from output of `convertsprite`
        [ sprite_segment , sprite_index + 9] = 0; // Color from output of `convertsprite`
    }
    if map_y == MAP_HEIGHT - 1 {
        [ sprite_segment , sprite_index ] = 0; // Disable
    }
    sprite_index = sprite_index + 16;
    // Draw layout of current room
    room_layout_minimap = 15 & [ MAP_SEGMENT , map_index ];
        i = 0;
        minimap_sprite_offset = 0;
        while i < room_layout_minimap {
            minimap_sprite_offset = minimap_sprite_offset + MINIMAP_TILE_SIZE;
            i = i + 1;
        }
    [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
    [ sprite_segment , sprite_index + 1] = MINIMAP_LEFT_X + MINIMAP_TILE_WIDTH + MINIMAP_TILE_MARGIN; // X
    [ sprite_segment , sprite_index + 2] = MINIMAP_TOP_Y + MINIMAP_TILE_HEIGHT + MINIMAP_TILE_MARGIN; // Y
    [ sprite_segment , sprite_index + 3] = MINIMAP_TILE_WIDTH; // Width
    [ sprite_segment , sprite_index + 4] = MINIMAP_TILE_HEIGHT; // Height
    [ sprite_segment , sprite_index + 5] = MINIMAP_SPRITE_SEGMENT; // Sprite segment
    [ sprite_segment , sprite_index + 6] = minimap_sprite_offset; // Sprite offset
    [ sprite_segment , sprite_index + 7] = 255; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = 0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = 0; // Color from output of `convertsprite`
}

// Uses sprite attributes 66.16 through 66.64 (inclusive)
// Sets has_top_door, has_bottom_door, has_left_door, has_right_door
// Based on door_layout
func renderRoomDoors {
    sprite_segment = 66;
    sprite_index = 16;

    // Top door
    has_top_door = door_layout == DOOR_CROSS;
    tmp = door_layout == DOOR_DEAD_UP;
    has_top_door = tmp | has_top_door;
    tmp = door_layout == DOOR_ELBOW_UP_LEFT;
    has_top_door = tmp | has_top_door;
    tmp = door_layout == DOOR_ELBOW_UP_RIGHT;
    has_top_door = tmp | has_top_door;
    tmp = door_layout == DOOR_VERTICAL;
    has_top_door = tmp | has_top_door;
    tmp = door_layout == DOOR_TEE_LEFT;
    has_top_door = tmp | has_top_door;
    tmp = door_layout == DOOR_TEE_UP;
    has_top_door = tmp | has_top_door;
    tmp = door_layout == DOOR_TEE_RIGHT;
    has_top_door = tmp | has_top_door;
    [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
    [ sprite_segment , sprite_index + 1] = 96; // X: 6 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height
    if has_top_door {
        // Door horizontal sprite is at [ 130 , 0 ]
        [ sprite_segment , sprite_index + 5] = 130; // Sprite segment
    }
    if has_top_door == 0 {
        // Horizontal wall sprite is at [ 129 , 0 ]
        [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    }
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 32;

    // Bottom door
    has_bottom_door = door_layout == DOOR_CROSS;
    tmp = door_layout == DOOR_DEAD_DOWN;
    has_bottom_door = tmp | has_bottom_door;
    tmp = door_layout == DOOR_ELBOW_DOWN_LEFT;
    has_bottom_door = tmp | has_bottom_door;
    tmp = door_layout == DOOR_ELBOW_DOWN_RIGHT;
    has_bottom_door = tmp | has_bottom_door;
    tmp = door_layout == DOOR_VERTICAL;
    has_bottom_door = tmp | has_bottom_door;
    tmp = door_layout == DOOR_TEE_LEFT;
    has_bottom_door = tmp | has_bottom_door;
    tmp = door_layout == DOOR_TEE_DOWN;
    has_bottom_door = tmp | has_bottom_door;
    tmp = door_layout == DOOR_TEE_RIGHT;
    has_bottom_door = tmp | has_bottom_door;
    [ sprite_segment , sprite_index ] = 176; // Enable, transparency, and flip vertically
    [ sprite_segment , sprite_index + 1] = 96; // X: 6 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 2] = 176; // Y: 11 tiles down, each 16 pixels wide
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height
    if has_bottom_door {
        // Door horizontal sprite is at [ 130 , 0 ]
        [ sprite_segment , sprite_index + 5] = 130; // Sprite segment
    }
    if has_bottom_door == 0 {
        // Horizontal wall sprite is at [ 129 , 0 ]
        [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    }
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 48;

    // Left door
    has_left_door = door_layout == DOOR_CROSS;
    tmp = door_layout == DOOR_DEAD_LEFT;
    has_left_door = tmp | has_left_door;
    tmp = door_layout == DOOR_ELBOW_DOWN_LEFT;
    has_left_door = tmp | has_left_door;
    tmp = door_layout == DOOR_ELBOW_UP_LEFT;
    has_left_door = tmp | has_left_door;
    tmp = door_layout == DOOR_HORIZONTAL;
    has_left_door = tmp | has_left_door;
    tmp = door_layout == DOOR_TEE_LEFT;
    has_left_door = tmp | has_left_door;
    tmp = door_layout == DOOR_TEE_DOWN;
    has_left_door = tmp | has_left_door;
    tmp = door_layout == DOOR_TEE_UP;
    has_left_door = tmp | has_left_door;
    [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
    [ sprite_segment , sprite_index + 2] = 80; // Y: 5 tiles down, each 16 pixels wide
    [ sprite_segment , sprite_index + 3] = 16; // Width
    [ sprite_segment , sprite_index + 4] = 32; // Height
    if has_left_door {
        // Door vertical sprite is at [ 130 , 128 ]
        [ sprite_segment , sprite_index + 5] = 130; // Sprite segment
        [ sprite_segment , sprite_index + 6] = 128; // Sprite offset
    }
    if has_left_door == 0 {
        // Vertical wall sprite is at [ 129 , 128 ]
        [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
        [ sprite_segment , sprite_index + 6] = 128; // Sprite offset
    }
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 64;

    // Right door
    has_right_door = door_layout == DOOR_CROSS;
    tmp = door_layout == DOOR_DEAD_RIGHT;
    has_right_door = tmp | has_right_door;
    tmp = door_layout == DOOR_ELBOW_DOWN_RIGHT;
    has_right_door = tmp | has_right_door;
    tmp = door_layout == DOOR_ELBOW_UP_RIGHT;
    has_right_door = tmp | has_right_door;
    tmp = door_layout == DOOR_HORIZONTAL;
    has_right_door = tmp | has_right_door;
    tmp = door_layout == DOOR_TEE_RIGHT;
    has_right_door = tmp | has_right_door;
    tmp = door_layout == DOOR_TEE_DOWN;
    has_right_door = tmp | has_right_door;
    tmp = door_layout == DOOR_TEE_UP;
    has_right_door = tmp | has_right_door;
    [ sprite_segment , sprite_index ] = 208; // Enable, transparency, and flip horizontally
    [ sprite_segment , sprite_index + 1] = 208; // X: 13 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 2] = 80; // Y: 5 tiles down, each 16 pixels wide
    [ sprite_segment , sprite_index + 3] = 16; // Width
    [ sprite_segment , sprite_index + 4] = 32; // Height
    if has_right_door {
        // Door vertical sprite is at [ 130 , 128 ]
        [ sprite_segment , sprite_index + 5] = 130; // Sprite segment
        [ sprite_segment , sprite_index + 6] = 128; // Sprite offset
    }
    if has_right_door == 0 {
        // Vertical wall sprite is at [ 129 , 128 ]
        [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
        [ sprite_segment , sprite_index + 6] = 128; // Sprite offset
    }
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
}

// Uses sprite attributes at addresses 66.80 through ??? because # of room tiles varies per room
func renderRoomTiles {
    sprite_segment = 66;
    sprite_index = 80;
    y = 0;
    y2 = TILE_HEIGHT;
    i = 0; // x + (y * ROOM_LAYOUT_WIDTH)
    while y < ROOM_LAYOUT_HEIGHT {
        x = 0;
        x2 = TILE_WIDTH;
        while x < ROOM_LAYOUT_WIDTH {
            tile_type = [ room_layout_segment , room_index + i ];
            tile_sprite = tile_type & 15; // 0000 1111 mask
            tile_type = tile_type & 240; // 1111 0000 mask
            tile_type = tile_type >> 4;
            i2 = 0;
            tile_sprite_offset = 0;
            tile_sprite_segment_offset = 0;
            while i2 < tile_sprite {
                i2 = i2 + 1;
                if tile_sprite_offset == 192 { // About to overflow tile_sprite_offset back to 0
                    tile_sprite_segment_offset = tile_sprite_segment_offset + 1;
                }
                tile_sprite_offset = tile_sprite_offset + TILE_SPRITE_SIZE;
            }
            if tile_type == 0 {
                [ sprite_segment , sprite_index ] = 0; // Disable
            }
            if tile_type > 0 {
                i2 = 0;
                while i2 < tile_type - 1 {
                    i2 = i2 + 1;
                    tile_sprite_segment_offset = tile_sprite_segment_offset + 4; // 4 16x16 sprites per segment
                }
                [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
                [ sprite_segment , sprite_index + 1] = x2; // X
                [ sprite_segment , sprite_index + 2] = y2; // Y
                [ sprite_segment , sprite_index + 3] = TILE_WIDTH; // Width
                [ sprite_segment , sprite_index + 4] = TILE_HEIGHT; // Height
                [ sprite_segment , sprite_index + 5] = TILE_SPRITE_SEGMENT + tile_sprite_segment_offset; // Sprite segment
                [ sprite_segment , sprite_index + 6] = tile_sprite_offset; // Sprite offset
                [ sprite_segment , sprite_index + 7] = tile_color_0; // Color from output of `convertsprite`
                [ sprite_segment , sprite_index + 8] = tile_color_1; // Color from output of `convertsprite`
                [ sprite_segment , sprite_index + 9] = tile_color_2; // Color from output of `convertsprite`
            }
            if sprite_index == 240 {
                sprite_segment = sprite_segment + 1;
            }
            sprite_index = sprite_index + 16;
            [ x , y ] = 0;
            if tile_type > TILE_TYPE_WALL {
                [ x , y ] = 1;
            }
            x = x + 1;
            x2 = x2 + TILE_WIDTH;
            i = i + 1;
        }
        y = y + 1;
        y2 = y2 + TILE_HEIGHT;
    }
}

// Uses sprite attributes at addresses 64.0 through 66.0 (inclusive)
func renderRoomBorder {
    // Set up sprite attributes to render the room.
    // These should only be done once at the start.
    sprite_segment = 64;
    sprite_index = 0;
    // -- Top left corner
    [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
    // [ sprite_segment , sprite_index + 1] = 0; // X
    // [ sprite_segment , sprite_index + 2] = 0; // Y
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 32; // Height
    // Corner wall sprite is at the start of ROM so the address is [ 128 , 0 ]
    [ sprite_segment , sprite_index + 5] = 128; // Sprite segment
    // [ sprite_segment , sprite_index + 6] = 0; // Sprite offset
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    // [ sprite_segment , sprite_index + 10] = 0; // Unused color (we're using transparency)
    sprite_index = 32; // Move to next sprite attribute

    // -- Top right corner
    [ sprite_segment , sprite_index ] = 208; // Enable, transparent, and flip horizontally
    [ sprite_segment , sprite_index + 1] = 192; // X: 12 tiles, each 16 pixels wide
    [ sprite_segment , sprite_index + 2] = 0; // Y
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 32; // Height
    [ sprite_segment , sprite_index + 5] = 128; // Sprite segment
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 48; // Move to next sprite attribute

    // -- Bottom right corner
    [ sprite_segment , sprite_index ] = 240; // Enable, transparent and flip horizontally and vertically
    [ sprite_segment , sprite_index + 1] = 192; // X: 12 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 2] = 160; // Y: 10 tiles over, each 16 pixels tall
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 32; // Height
    [ sprite_segment , sprite_index + 5] = 128; // Sprite segment
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 64; // Move to next sprite attribute

    // -- Bottom left corner
    [ sprite_segment , sprite_index ] = 176; // Enable, transparent, and flip vertically
    [ sprite_segment , sprite_index + 1] = 0; // X
    [ sprite_segment , sprite_index + 2] = 160; // Y: 10 tiles over, each 16 pixels tall
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 32; // Height
    [ sprite_segment , sprite_index + 5] = 128; // Sprite segment
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 80; // Move to next sprite attribute
    
    // -- Top walls (but not door area)
    [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
    [ sprite_segment , sprite_index + 1] = 32; // X: 2 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 96; // Move to next sprite attribute

    [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
    [ sprite_segment , sprite_index + 1] = 64; // X: 4 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 112; // Move to next sprite attribute

    [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
    [ sprite_segment , sprite_index + 1] = 128; // X: 8 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 128; // Move to next sprite attribute

    [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
    [ sprite_segment , sprite_index + 1] = 160; // X: 10 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 144; // Move to next sprite attribute

    // -- Bottom Walls (but not door area)
    [ sprite_segment , sprite_index ] = 176; // Enable, transparency, and flip vertically
    [ sprite_segment , sprite_index + 1] = 32; // X: 2 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 2] = 176; // Y: 11 tiles down, each 16 pixels wide
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 160; // Move to next sprite attribute

    [ sprite_segment , sprite_index ] = 176; // Enable, transparency, and flip vertically
    [ sprite_segment , sprite_index + 1] = 64; // X: 4 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 2] = 176; // Y: 11 tiles down, each 16 pixels wide
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 176; // Move to next sprite attribute

    [ sprite_segment , sprite_index ] = 176; // Enable, transparency, and flip vertically
    [ sprite_segment , sprite_index + 1] = 128; // X: 8 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 2] = 176; // Y: 11 tiles down, each 16 pixels wide
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 192; // Move to next sprite attribute

    [ sprite_segment , sprite_index ] = 176; // Enable, transparency, and flip vertically
    [ sprite_segment , sprite_index + 1] = 160; // X: 10 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 2] = 176; // Y: 11 tiles down, each 16 pixels wide
    [ sprite_segment , sprite_index + 3] = 32; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 208; // Move to next sprite attribute

    // -- Left Walls (but not door area)
    [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
    [ sprite_segment , sprite_index + 2] = 32; // Y: 2 tiles down, each 16 pixels tall
    [ sprite_segment , sprite_index + 3] = 16; // Width
    [ sprite_segment , sprite_index + 4] = 32; // Height
    // Vertical wall sprite is at at [ 129 , 128 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 6] = 128; // Sprite offset
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 224; // Move to next sprite attribute

    [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
    [ sprite_segment , sprite_index + 2] = 64; // Y: 4 tiles down, each 16 pixels tall
    [ sprite_segment , sprite_index + 3] = 16; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height (short wall tile)
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 6] = 128; // Sprite offset
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 240; // Move to next sprite attribute

    [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
    [ sprite_segment , sprite_index + 2] = 112; // Y: 7 tiles down, each 16 pixels tall
    [ sprite_segment , sprite_index + 3] = 16; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height (short wall tile)
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 6] = 128; // Sprite offset
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_segment = 65; // Use next segment of sprite attributes
    sprite_index = 0; // Move to next sprite attribute

    [ sprite_segment , sprite_index ] = 144; // Enable and use transparency
    [ sprite_segment , sprite_index + 2] = 128; // Y: 8 tiles down, each 16 pixels tall
    [ sprite_segment , sprite_index + 3] = 16; // Width
    [ sprite_segment , sprite_index + 4] = 32; // Height
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 6] = 128; // Sprite offset
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 16; // Move to next sprite attribute

    // -- Right Walls (but not door area)
    [ sprite_segment , sprite_index ] = 208; // Enable, transparency, and flip horizontally
    [ sprite_segment , sprite_index + 1] = 208; // X: 13 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 2] = 32; // Y: 2 tiles down, each 16 pixels tall
    [ sprite_segment , sprite_index + 3] = 16; // Width
    [ sprite_segment , sprite_index + 4] = 32; // Height
    // Vertical wall sprite is at at [ 129 , 128 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 6] = 128; // Sprite offset
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 224; // Move to next sprite attribute

    [ sprite_segment , sprite_index ] = 208; // Enable, transparency, and flip horizontally
    [ sprite_segment , sprite_index + 1] = 208; // X: 13 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 2] = 64; // Y: 4 tiles down, each 16 pixels tall
    [ sprite_segment , sprite_index + 3] = 16; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height (short wall tile)
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 6] = 128; // Sprite offset
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 240; // Move to next sprite attribute

    [ sprite_segment , sprite_index ] = 208; // Enable, transparency, and flip horizontally
    [ sprite_segment , sprite_index + 1] = 208; // X: 13 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 2] = 112; // Y: 7 tiles down, each 16 pixels tall
    [ sprite_segment , sprite_index + 3] = 16; // Width
    [ sprite_segment , sprite_index + 4] = 16; // Height (short wall tile)
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 6] = 128; // Sprite offset
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_segment = 66; // Use next segment of sprite attributes
    sprite_index = 0; // Move to next sprite attribute

    [ sprite_segment , sprite_index ] = 208; // Enable, transparency, and flip horizontally
    [ sprite_segment , sprite_index + 1] = 208; // X: 13 tiles over, each 16 pixels wide
    [ sprite_segment , sprite_index + 2] = 128; // Y: 8 tiles down, each 16 pixels tall
    [ sprite_segment , sprite_index + 3] = 16; // Width
    [ sprite_segment , sprite_index + 4] = 32; // Height
    // Horizontal wall sprite is at at [ 129 , 0 ]
    [ sprite_segment , sprite_index + 5] = 129; // Sprite segment
    [ sprite_segment , sprite_index + 6] = 128; // Sprite offset
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
}

func updateRoomBorderColors {
    // Set up sprite attributes to render the room.
    // These should only be done once at the start.
    sprite_segment = 64;
    sprite_index = 0;
    // -- Top left corner
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    // [ sprite_segment , sprite_index + 10] = 0; // Unused color (we're using transparency)
    sprite_index = 32; // Move to next sprite attribute

    // -- Top right corner
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 48; // Move to next sprite attribute

    // -- Bottom right corner
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 64; // Move to next sprite attribute

    // -- Bottom left corner
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 80; // Move to next sprite attribute
    
    // -- Top walls (but not door area)
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 96; // Move to next sprite attribute

    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 112; // Move to next sprite attribute

    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 128; // Move to next sprite attribute

    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 144; // Move to next sprite attribute

    // -- Bottom Walls (but not door area)
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 160; // Move to next sprite attribute

    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 176; // Move to next sprite attribute

    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 192; // Move to next sprite attribute

    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 208; // Move to next sprite attribute

    // -- Left Walls (but not door area)
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 224; // Move to next sprite attribute

    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 240; // Move to next sprite attribute

    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_segment = 65; // Use next segment of sprite attributes
    sprite_index = 0; // Move to next sprite attribute

    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 16; // Move to next sprite attribute

    // -- Right Walls (but not door area)
    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 224; // Move to next sprite attribute

    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_index = 240; // Move to next sprite attribute

    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
    sprite_segment = 66; // Use next segment of sprite attributes
    sprite_index = 0; // Move to next sprite attribute

    [ sprite_segment , sprite_index + 7] = wall_color_0; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 8] = wall_color_1; // Color from output of `convertsprite`
    [ sprite_segment , sprite_index + 9] = wall_color_2; // Color from output of `convertsprite`
}

func waitScreen {
    while GPU_state == previous_GPU_state {
        GPU_state = [ 127 , 17 ];
        GPU_state = GPU_state & 2;
    }
    previous_GPU_state = GPU_state;
}
